---
title: "Models of SAR-CoV-2 mutation counts:dS versus ds + syn counts (pS) "
author: "T Bataillon"
date: "last update: `r Sys.Date()`)"
output:
  html_document:
    theme: united
    code_folding: show
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: console
---


```{r}
source("analysis/hard_coded_params.R")
```

# Using data version: `r data_path`

# Brief history of rmd file: 

* July 13
* inspired and tweaked version of S4 but playing with the nb of syn counts in the window as covariate
* trying with all periods and then "nesting by period and lineage" as example

```{r, include=FALSE}
suppressPackageStartupMessages(library(tidyverse)) # to avoid messy 
library(ggsci)
library(ggrepel)
library(cowplot)
library(knitr)
library(MASS)
library(ggthemes)
library(modelr)
library(ciTools)
```

# Loading data from rds annotated windows  
```{r}
df_muts_and_covs1 <- readRDS("output/data_100pb_pangolin_period1_withCovs.rds")
df_muts_and_covs1$period <- "I"

df_muts_and_covs2 <- readRDS("output/data_100pb_pangolin_period2_withCovs.rds")
df_muts_and_covs2$period <- "II"

df_muts_and_covs3 <- readRDS("output/data_100pb_pangolin_period3_withCovs.rds")
df_muts_and_covs3$period <- "III"

df_muts_and_covs <- rbind(df_muts_and_covs1, df_muts_and_covs2, df_muts_and_covs3)
dim(df_muts_and_covs)
summary(df_muts_and_covs)
table(df_muts_and_covs$pangolin_lineage) %>% t() %>% knitr::kable() # 614*3 windows expected per lineage
```

# data summaries before modeling counts
Summaries of counts, including the variance to mean ratio that is a good indicator of Poisson like distribution (expect 1 under Poisson):

```{r}
df_muts_and_covs %>%
  group_by(pangolin_lineage, period, type) %>%
  summarise(n=n(),
            mean = mean(unique_mutations), 
            var = var(unique_mutations),
            ratio = var/mean) %>%
  knitr::kable(digits = 2)

```

## The distributions of counts (for period III)

```{r}
df_muts_and_covs %>% 
  filter(period =="III") %>%
ggplot(aes(x =unique_mutations, fill = type))+
  geom_histogram(binwidth = 1)+
  facet_wrap(~ pangolin_lineage + type , ncol = 2, strip.position = "right")+
  theme_minimal(base_size = 15)+
  xlab("nb unique mutations per window (gisaid)")+
  scale_fill_viridis_d()+
  theme_cowplot(font_size = 12)+
  theme(legend.position = "top")+
  NULL
```

# Exploring dS versus counts 
```{r}
names(df_muts_and_covs)
df_muts_and_covs %>%
  filter( period == "III") %>%
  ggplot(aes(y = log(1+unique_mutations), x = log(1+R.G.dS) )) + 
  geom_jitter(width = 0.1)+ 
  geom_smooth()+
  facet_wrap(~pangolin_lineage + period, ncol = 2 ,scales = "free_y")

```



# Adding  the local number of mutations as an extra covariate 

`df_tofit` is the data (non-synonymous counts as response variable)

```{r}
adhocdf <- df_muts_and_covs %>%
  filter( type == "S") %>%
  mutate(pS = log(1+ unique_mutations))

df_tofit <- df_muts_and_covs %>%
  filter( type == "NS")

df_tofit$pS <- adhocdf$pS
df_tofit$checkme <- adhocdf$gene_bin
# adhocdf$gene_bin == df_tofit$gene_bin
#check
```

# Nesting datasets by period & lineage

```{r}

by_type <- df_tofit %>% 
  group_by(period, pangolin_lineage) %>% 
  nest()
```


## Step 2 : Make model fitting function(s).


Note that the function is an adhoc "wrapper" for a given model. Technically we want to have a series of models and these are "coded manually" just once.

Here I try with a simple minded $m_0$, $m_1$ up to $m_3$  in practice we might have to code a series of models we agree upon :=)


```{r}
fitting_m00 <- function(my_df) {
  glm(unique_mutations ~ 1 , data = as.data.frame(my_df), family = poisson)
}

fitting_m0 <- function(my_df) {
  glm.nb(unique_mutations ~ 1 , data = as.data.frame(my_df))
}

fitting_m1 <- function(my_df) {
  glm.nb(unique_mutations ~ W.R.dS  , data = as.data.frame(my_df))
}

fitting_m2 <- function(my_df) {
  glm.nb(unique_mutations ~ W.R.dS + pS , data = as.data.frame(my_df))
}

```


# Fitting only one model at a time 
```{r}


model_m00 <- purrr::map(.x = by_type$data, .f = fitting_m00)

```

## Step 3: mapping a model function to the nested data


```{r,warning=F}
by_type <- by_type %>% 
  mutate(model_m00 = purrr::map(data, fitting_m00),
         model_m0 = purrr::map(data, fitting_m0),
         model_m1 = purrr::map(data, fitting_m1),
         model_m2 = purrr::map(data, fitting_m2))
```

## Overview of models AIC 

Borrowed from the r4ds book ... but not super useful 
Need to also be made more "functional"...

```{r}

summary_m00 <- by_type %>% 
  mutate(glance00 = map(model_m00, broom::glance)) %>% 
  unnest(glance00)
summary_m0 <- by_type %>% 
  mutate(glance0 = map(model_m0, broom::glance)) %>% 
  unnest(glance0)

summary_m1 <- by_type %>% 
  mutate(glance1 = map(model_m1, broom::glance)) %>% 
  unnest(glance1)

summary_m2 <- by_type %>% 
  mutate(glance2 = map(model_m2, broom::glance)) %>% 
  unnest(glance2)

final_tbl <- tibble (phase= by_type$period, Lineage = by_type$pangolin_lineage,
        m00_aic = summary_m00$AIC, 
        m0_aic = summary_m0$AIC,
        m1_aic = summary_m1$AIC,
        m2_aic = summary_m2$AIC)
        
final_tbl %>%
  arrange(phase) %>%
  kable(digits = 2)
```

# Extracting confidence intervals under M2 (comparison to to be done) 

I use an adhoc wrapper of add_ci() to specify the alpha level of the Ci to build
Note that `ci_alpha` is hard coded and needs to be updated: 

Here I fit using model $m_1$
```{r}
ci_alpha <- 0.05/(307*3) # hardcoded here ...to be  moved to hard_coded_params.R ? 

add_ci_at_alpha <- function (dataX, modelY){
  return(add_ci(df = dataX,  fit= modelY, alpha= ci_alpha))
}

by_type <- by_type %>%
  mutate(cis_m2 = map2(data, model_m2, add_ci_at_alpha)
  )

by_type_m1 <- unnest(by_type, cis_m2)
names(by_type_m1)
dim(by_type_m1)
```

# Plot:  fitted model and counts  

## Obs versus predicted along the genome (under M2)
I am just doing a quick and dirty visual of the observed counts versus the upper CI at the $\alpha$ level

```{r}
by_type_m1 <- 
  by_type_m1 %>%
  mutate(categ = ifelse( (unique_mutations > UCB0.999972855591748 ), "HA", "H0"))
names(by_type_m1)
```

##  final graphs by linages 

```{r}
sars_annot <- readRDS("data/proteins_sarscov2_genome_positions.rds")
```

```{r}
by_type_m1 %>%
  filter(pangolin_lineage %in% c("B.1.1.7", "B.1.351", "P.1")) %>%
  ggplot(aes(x=window_start_gis)) + 
  # geom_point(aes(y=Count), color="grey", size =0.4)+
  geom_point(aes(y=unique_mutations, color= categ))+
  xlab("genomic positions (windows of 100nt)")+ 
  facet_wrap(~ pangolin_lineage + period, ncol = 1,  
             strip.position = "top", scales = "free_y")+
  theme(legend.position = "top") + 
  scale_color_colorblind()+
  theme_cowplot(font_size = 14)+
  annotate("text", x = 21563, y = -1, label = "S", size=2)+
  annotate("text", x = 26523, y = -1, label = "M", size=2)+
  annotate("text", x = 28274, y = -1, label = "N", size=2)+
  NULL
```



